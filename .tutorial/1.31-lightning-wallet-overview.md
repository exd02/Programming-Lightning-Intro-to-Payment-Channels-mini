# Lightning Wallet Deep Dive 

If you're reading this, you've found yourself in one of the "deep dive" sections of this workbook. Good luck on this journey - you will need it! (Kidding?)

The rest of this appendix assumes a high-level understanding of elliptic curve cryptography. If you'd like a quick refresher, **learn me a bitcoin** provides an excellent resource [here](https://learnmeabitcoin.com/technical/cryptography/elliptic-curve/).

## Starting With The End In Mind
Let's start by reviewing our end goal: **We need to create unique public and private keys that can be used for each spending path in our commitment transaction outputs**.

In the below diagram, you can see each public key that Alice will provide for this arbitrary channel state between Alice and Bob. NOTE: for simplicity, the HTLC output is *not* pictured, but Alice will have an HTLC public key embedded within the HTLC output for both her commitment transaction and Bob's commitment transaction. 

The most important thing to take away from this diagram is that *most* of the public keys that are placed in each spending path are a **combination** of two *public keys*: a **basepoint** and a **per commitment point**. The rest of this appendix will dive deep into how we *create* the **basepoints** and the **per commitment points** such that we can build the output scripts needed for our Lightning channels.

The notable exception is that `our_payment_pubkey`, which is placed in the remote node's `to_remote` output is simply our Payment Basepoint. Likewise, when we create a `to_remote` output on our commitment transaction, it will simply be our counterparty's Payment Basepoint. This way, we protect our counterparty such that they can still spend their output, even if they lost data and forget the corresponding **per commitment point**.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/basepoint_keys.png" alt="basepoint_keys" width="100%" height="auto">
</p>

### Ensuring Public Keys Are Unqiue For Each Commitment
Before digging into the details, it's important to stress that most public keys are unique for any given commitment transaction. To accomplish this, as mentioned above, we combine the following two public keys to create the resulting public key that is placed in the transaction output:
- **Per Commitment Point**: The per commitment point changes for each channel state. Since most public keys are combinations of the per commitment point and a given basepoint, this ensure the resulting public key used in the output script will be unique for each channel state. BOLT 3 provides specific guidance for how the **per commitment point** is created.
- **Basepoint**: The basepoints are constant across all commitment states.

For example, if you zoom into the below diagram, you'll see that we combine a unique **per commitment point** with the same **delayed payment basepoint** to create a unique public key for each commitment state. As a reminder, this public key will be used by Alice within the timelocked spending path that sends to herself.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/commitment_keys.png" alt="commitment_keys" width="100%" height="auto">
</p>

## Lightning Off-Chain Wallet Strucure
To properly understand how keys work in Lightning, it's helpul to contextualize them within the context of a Lightning node's wallet. For this deep dive, we'll focus on the **off-chain** portion of a node's wallet. To be clear, this means we'll be paying special attention to the keys that are ulitized for Lightning transactions, which are specified in [BOLT 3](https://github.com/lightning/bolts/blob/master/03-transactions.md). We won't devote time to covering the **on-chain** portion of a Lightning wallet. As a reminder, the on-chain wallet is used for things like funding Lightning channels, fee-bumping channel-closing transactions, and sending any on-chain payments your Lightning application may support. Some options for an on-chain wallet may be using Bitcoin Core's wallet or building your own with the [Bitcoin Development Kit](https://bitcoindevkit.org/).

Before digging into our Lightning wallet, let's set the scene by briefly reviewing **Bitcoin Improvement Proposal (BIP) 32**

BIP 32  describes a **hierarchical deterministic** (**HD**) wallet structure which introduces the following characteristics for key management:
- **Single Source**: All public and private keys can be derived from a single seed. As long as you have access to the seed, you can re-derive the entire wallet.
- **Hierarchical**: All keys can be organized in a tree structure.
- **Deterministic**: All keys are generated the same exact way. Each time you restore you wallet from your seed, you'll get the exact same result.

### Derivation Paths
Another useful property of HD wallets is that you can create unique derivation paths that act as different "accounts" or "use cases" for your keys. For example, in the context of the Lightning Network, we can create new child private keys for the following tasks:
- **Gossip Protocol**: Sign gossip announcements, decode onion data, etc.
- **Channel Close**: Derive private and public keys which can be used to generate addresses that we can use when locking up funds on-chain during channel closure.
- **Payment Channel**: Help derive all of the public and private keys we need to operate a payment channel. Note, each channel will have its own child key from this derivation path. We'll learn more about the various keys used in a Lightning channel shortly, but, as a brief teaser, they are:
  - Revocation Key
  - HTLC Key
  - Delayed Payment Key
  - Payment Key

For a deeper dive into derivation paths, please see this [resource](https://learnmeabitcoin.com/technical/keys/hd-wallets/derivation-paths/) by Learn Me A Bitcoin.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/ldk_keys_ex.png" alt="ldk_keys_ex" width="40%" height="auto">
</p>

### Key Management
Okay, now that we've reviewed BIP 32 and seen how we can create an organized tree of public and private keys, let's see how we can put this theory into practice.

Below is a *rough* diagram of how we can organize **off-chain** Lightning keys, inspired by LDK's default [`KeysManger`](https://docs.rs/lightning/latest/lightning/sign/struct.KeysManager.html). Some details are abstracted away because the *exact implementation* isn't neccessary from a learning perspective. With that said, the overall architecture is described below:

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/ldk_keys.png" alt="ldk_keys" width="100%" height="auto">
</p>

- **Seed**: We kick-start our Lightning wallet by providing a seed. This is just a 32-byte (very large) random number. This can be a stand-alone seed, or it can itself be a hardened derivation path from a higher-level HD wallet.
  <details>
    <summary>Click to see picture of seed in diagram above</summary>

  <p align="center" style="width: 50%; max-width: 300px;">
    <img src="./tutorial_images/wallet_seed.png" alt="wallet_seed" width="50%" height="auto">
  </p>

  </details>

- **Derivation Paths**: From our seed, we create multiple **hardened public/private key pairs** for various Lightning operations. It's important to create hardened devivation paths so that, if we leak private key information for one of the derivation paths, the rest of our Lightning keys are not at risk.
  <details>
    <summary>Click to see picture of derivation paths in diagram above</summary>
  
  <p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/wallet_paths.png" alt="wallet_paths" width="50%" height="auto">
  </p>
  
  </details>
- **Channel Keys**: For each channel, we derive a series of **basepoints** (points on elliptic curve) and **basepoint secrets** (256-bit scalars). We call them "basepoints" to emphasize their specific role as foundational points in the elliptic curve cryptography key derivation process for generating per-commitment keys.
  - To make things a little more concrete, the formula for calculating a public key for a spending path is the following: `pubkey = basepoint + SHA256(per_commitment_point || basepoint) * G`. As you can see, the **basepoint** itself is only one of them components needed to derive a public key. We'll learn more about this later, so don't worry if it's not entirely clear yet.

  - Below is a list of the basepoints and basepoint secrets used in the Lightning Network:
    - **Revocation Basepoint + Secret**: Basepoint/Secret used to derive revocation keys.
    - **Payment Basepoint + Secret**: Basepoint/Secret used for our balance (ex: `to_remote`) in counterparty's commitment transactions.
    - **Delayed Payment Basepoint + Secret**: Basepoint/Secret used to derive keys for delayed paths (ex: `to_local`).
    - **HTLC Basepoint + Secret**: Basepoint/Secret used to derive keys in commitment transaction HTLC outputs.
    - **Commitment Seed**: The commitment seed is a 256-bit scalar used to generate a series of secrets **for each commitment state**. As we'll soon learn, these secrets will combined with the above basepoints/secrets to generate the private and public keys used in each commitment transactions output scripts.
  <details>
    <summary>Click to see picture of channel keys in diagram above</summary>

  <p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/wallet_channel_keys.png" alt="wallet_channel_keys" width="50%" height="auto">
  </p>

  </details>
- **Per-Commitment Keys**: As mentioned above, each commitment transaction will use the **basepoints** and a **per-commitment** private/public key, derived from the **commitment seed**, to create specific public and private keys for each output. Remember, except for the `to_remote` output, we don't use the basepoints themselves in our outputs! By doing this, we can ensure the keys for each commitment state are deterministically derivable in an efficient way and unqiue for each commitment.

  <details>
    <summary>Click to see picture of per-commitment keys in diagram above</summary>

  <p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/wallet_commit_keys.png" alt="wallet_commit_keys" width="50%" height="auto">
  </p>

  </details>

<details>
  <summary>Click to see example of creating a tranasction-specific public key</summary>
  
Each commitment transaction will have a new and unique **delayed payment public key**, which is used in the transaction-holder's `to_local` output - specifically, in the timelocked spending path that pays to the transaction holder. To accomplish this, BOLT 3 provides instructions on how to utilize the above keys to calculate a new  **delayed payment public key**.

We'll dig into the exact equation shortly, but, for now, it's sufficient to note that you must combine the **Per-Commitment Public Key** (which is derived from the **Commitment Seed**) and the **Delayed Payment Basepoint** to create the delayed payment public key used in the output. 

<p align="center" style="width: 50%; max-width: 300px;">
<img src="./tutorial_images/delayed_key_ex.png" alt="delayed_key_ex" width="100%" height="auto">

</details>


## ⚡️ Build a NodeKeysManager to Manager Our Node-Level Keys
For this exercise, we're going to implement the `new` method on our `NodeKeysManager`, which will provide us with the cryptographic material needed to create the rest of our Lightning node wallet. Specifically, the new method will create the following keys, and return a `NodeKeysManager` structure, which we will later use to create they keys needed for each channel.
- **Node Secret**:  Private Key, derived from hardened child at index `0`. This is used to sign gossip announcements, decode onion data, etc.
- **Node ID**:  Public Key, derived from Node Secret. This identifies our node on the Lightning network.
- **Shutdown Extended Public Key**: Extended Public Key. To close a Lightning channel, you send a `shutdown` message to your peer, as defined in [BOLT 2](https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#closing-initiation-shutdown). This message includes the `channel_id` and `scriptpubkey`, which can be script such as Pay-To-Public-Key-Hash or Pay-To-Witness-Script-Hash. The Shutdown Extended Public Key can be used to derive a new scriptpubkey for each cooperative closure.
- **Channel Master Key**: Extended Private Key, derived from hardened child at index `2`. As we'll soon see, we can use this extended private key to create a child private key for each channel our Lightning node opens.

```rust
pub struct NodeKeysManager {
    pub secp_ctx: Secp256k1<secp256k1::All>,
    pub node_secret: SecretKey,
    pub node_id: PublicKey,
    pub shutdown_xpub: Xpub,
    pub channel_master_key: Xpriv,
    pub seed: [u8; 32],
}
```

```rust
impl NodeKeysManager {
pub(crate) fn new(seed: [u8; 32]) -> NodeKeysManager {
  
    // Step 1: Initialize the Secp256k1 Context

    // Step 2: Derive the Master Key from the Seed

    // Step 3: Derive the Node Secret at Hardened Index 0

    // Step 4: Derive the Node ID from the Node Secret

    // Step 5: Derive the Cooperative Close Public Key at Hardened Index 1

    // Step 6: Derive the Channel Master Key at Hardened Index 2

    // Step 7: Construct and Return the NodeKeysManager Struct

    // NodeKeysManager {
        // secp_ctx: secp_ctx,
        // channel_master_key: channel_master_key,
        // node_secret: node_secret,
        // node_id: node_id,
        // seed: seed,
    // }
}
```

<details>
  <summary>Step 1: Initialize the Secp256k1 Context</summary>

Since we'll be performing cryptographic operations in this exercise, we'll need to start by defining a variable that can perform those cryptographic operations for us. To do that, we can use the `Secp256k1` crate.

```rust
let secp_ctx = Secp256k1::new();
```
</details>

<details>
  <summary>Step 2: Derive the Master Key from the Seed</summary>

Since our function takes a 32-byte `seed` as input, we can use it to generate a BIP-32 extended private key (master key) from which all other keys will be derived.

To do this, we can leverage the `Xpriv` type, provided by the `bip32` crate in rust-bitcoin. Since the derivation path will depend on the network type, we'll need to define the `network` and pass it into the `new_master` function, available on the `Xpriv` type.

This function will return a `Result` type, so we'll need to unwrap it before we can use it. In a robust application, we will want to handle this error more precisely.

```rust
let network = Network::Regtest;
let master_key = Xpriv::new_master(network, &seed).unwrap();
```
</details>

<details>
  <summary>Step 3: Derive the Node Secret at Hardened Index 0</summary>

The node secret is a private key derived from the master key at the hardened child index `0`. Our node will use this private key to sign messages that are communicated over the gossip network, proving those messages came from us.

You can derive a private key using the below code.

```rust
let node_secret = master_key
    .derive_priv(&secp_ctx, &ChildNumber::from_hardened_idx(0).unwrap())
    .expect("Your RNG is busted")
    .private_key;
```
</details>

<details>
  <summary>Step 4: Derive the Node ID from the Node Secret</summary>

Next, we'll need to derive the node ID. This is a public key, and it is used to identify our node on the Lightning Network. Other nodes may use this public key to create shared secrets with us, enabling them to encrypt messages (ex: routing payments via onion routing) such that only we can decrypt them.

You can derive a public key from a private key using the below code.

```rust
let node_id = PublicKey::from_secret_key(&secp_ctx, &node_secret);
```
</details>

<details>
  <summary>Step 5: Derive the Cooperative Close Public Key at Hardened Index 1</summary>

Now, let's derive the `shutdown_xpub` at hardened index 1 from the master key. We'll use this extended public key to generate a new  scriptpubkey (e.g., Pay-To-Public-Key-Hash) for each cooperative channel close, which will be communicated in the `shutdown` message.

```rust
let shutdown_xpub = Xpub::from_priv(
    &secp_ctx, 
    &master_key.derive_priv(&secp_ctx, &ChildNumber::from_hardened_idx(1).unwrap())
        .expect("Your RNG is busted")
);
```
</details>

<details>
  <summary>Step 6: Derive the Channel Master Key at Hardened Index 2</summary>

Now, to get the channel master key, we'll need to derive another hardened child key. In our case, we're going to derive this key at index `2`. One notable difference between this key and the `node_secret` is that this is an **extended private key**. Extended private keys can generate a tree of child keys (public and private) deterministically. This is quite useful for us, as we'd like to create a new public/private key pair *for each payment channel*. On the other hand, the `node_secret` is only needed to sign and decrypt messages related to our `node_id`, so this key does not need to be able to derive child keys.

If you'd like to learn more about extended keys, this is a great resource: https://learnmeabitcoin.com/technical/keys/hd-wallets/extended-keys/

You can derive an extended private key using the below code.

```rust
let channel_master_key = master_key
    .derive_priv(&secp_ctx, &ChildNumber::from_hardened_idx(2).unwrap())
    .expect("Your RNG is busted");
```
</details>

<details>
  <summary>Step 7: Construct and Return the NodeKeysManager Struct</summary>

Finally, assemble all the derived keys and the original seed into the `NodeKeysManager` struct and return it!

```rust
NodeKeysManager {
    secp_ctx: secp_ctx,
    node_secret: node_secret,
    node_id: node_id,
    shutdown_xpub: shutdown_xpub,
    channel_master_key: channel_master_key,
    seed: seed,
}
```
</details>