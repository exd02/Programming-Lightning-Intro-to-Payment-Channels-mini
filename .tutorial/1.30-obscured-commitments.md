# Obscured Commitment Number

Imagine you (Alice) and Bob have been sending payments back and forth for a while now. You've even reached 1,000,000 payments - wow! However, what if Bob tries to pull a fast one and publish an old commitment transaction? Remember, each channel state uses a unique set of private and public keys!

*Don't be afraid to zoom into the diagram below!*
<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/unknown_commit.png" alt="unknown_commit" width="100%" height="auto">
</p>

#### Question: How would you know which commitment state Bob is publishing so that you can punish him and reclaim all channel funds via the revocation path?


<details>
<summary>Answer</summary>

One idea is to simply store all previous transactions so that you can iterate through your history and see which state matches the transaction Bob posted. That said, this doesn't sound too efficient.

Another idea is to put the commitment number in the transaction itself. That way, you can just view the transaction data, identify the commitment number, and generate the keys needed to sign a new transaction that claims the funds locked in the revocation path.

Let's say we take this approach. **Where would you store the commitment number?** Remember, the max number of commitments we can generate is 2^48 - 1, so we need **6 bytes (48 bits)** of storage space!

Two possible options are the **locktime** and **sequence** fields, as those are not  used for a specific purpose in commitment transactions.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/tx_commitment_storage.png" alt="tx_commitment_storage" width="50%" height="auto">
</p>

#### Question: Why is it not a great idea to put the raw commitment number in the transaction, which is publicly observable on the blockchain?

<details>
<summary>Answer</summary>

If we embed the raw commitment number within the transaction, that would be a massive privacy leak, as anyone would be able to see how many commitment states our lightning channel had at the time of closure.

To prevent this privacy leak, the Lightning protocol specifies that we must *obscure* the number of commitments by using an **XOR** operation with a SHA256-derived factor (based on *both channel partner's*  **payment basepoints**). Since the payment basepoints should only be known by the channel parties, this ensures that outsiders will be unable to decipher the actual number of commitments.

Finally, since the number of commitments requires up to 6 bytes to store, we separate the obscured commitment number into two 24 bit chunks.
- The upper 24 bits are placed in the **Locktime** field, prefixed with `0x20` (8 bits) since this is a 4 byte field.
  - We prefix with `0x20` because it ensures the resulting locktime will evaluate to something above 536,870,912 but below 546,937,241. Since anything above 500,000,000 is interpreted as a Unix timestamp, and 536,870,912 - 546,937,241 is, roughly, around 1987, the locktime will always be a valid locktime in the past. Therefore, this workaround enables us to use this field for purposes other than the locktime - like storing data.
- The lower 24 bits are placed in the **sequence** field, prefixed with `0x80` (8 bits) since this is a 4 byte field.
  - Similar to the locktime field, we prefix with `0x80` because it disables any relative locktimes (in relation to the 2-of-2 multisig funding transaction). We're then free to use the rest of the 24 bits to store our commitment transaction data!

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/obscured_commitment.png" alt="obscured_commitment" width="100%" height="auto">
</p>

</details>

</details>


## ⚡️ Write A Function To Generate An Obscure Factor 

Let's get to work! First and foremost, to generate an obscured commitment number, we'll need to write a function to generate an obscure factor. This is what we'll use to XOR our commitment number.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/obscure_factor.png" alt="obscure_factor" width="50%" height="auto">
</p>

Complete `get_commitment_transaction_number_obscure_factor` in `src/exercises_appendix/exercises.rs`. This function takes the following parameters:
- `channel_open_payment_basepoint`: Public key (`&PublicKey`) of channel opener.
- `channel_accept_payment_basepoint`: Public key (`&PublicKey`) of channel accepter.

There's also a helper function `extract_lower_48_bits` provided in the same file, which takes a 32-byte input and returns the least-significant 48 bits as a `u64`. You can use it directly, or implement the bit extraction yourself if you'd like to get your hands dirty!

```rust
pub fn get_commitment_transaction_number_obscure_factor(
  channel_open_payment_basepoint: &PublicKey, channel_accept_payment_basepoint: &PublicKey,
) -> u64 {
  
  // Step 1: Initialize the SHA256 Engine

  // Step 2: Step 2: Serialize and Input Both Basepoints

  // Step 3: Finalize the Hash
  
  // Step 4: Extract and Return Lower 48 Bits

}
```

<details> <summary> Step 1: Initialize the SHA256 Engine </summary>

Create a new SHA256 hash engine.

```rust
let mut sha = Sha256::engine();
```

</details>

<details> <summary> Step 2: Serialize and Input Both Basepoints </summary>

Serialize the channel opener's and acceptor's payment basepoints into their compressed representations and input them into the hash engine in order (opener then acceptor). Per BOLT #3, the opener's basepoint comes first in the concatenation.

```rust
sha.input(&channel_open_payment_basepoint.serialize());
sha.input(&channel_accept_payment_basepoint.serialize());
```
- `sha.input(&... )` feeds the serialized bytes into the hash engine sequentially, effectively concatenating opener || acceptor.

</details>

<details> <summary> Step 3: Finalize the Hash </summary>

Complete the hashing process and retrieve the 32-byte SHA256 digest.

```rust
let res = sha256::Hash::from_engine(sha).to_byte_array();
```
- `sha256::Hash::from_engine(sha)` finalizes the hash computation and returns a sha256::Hash object.

</details>

<details> <summary> Step 4: Extract And Return Lower 48 Bits </summary>
  
Use the provided helper function to extract the least-significant 48 bits from the hash bytes. These bits form the obscure factor (mask).

```rust
extract_lower_48_bits(res)
```
- `extract_lower_48_bits(res)` handles the bit extraction for you, returning a u64 (since 48 bits fit comfortably in 64 bits).

</details>

## ⚡️ Write A Function To Build A Commitment Transaction Input

To create a commitment transaction input, we'll need to write a function that constructs a `TxIn` struct, incorporating an obscured commitment number as specified in BOLT #3. This function will XOR the commitment number with the obscure factor and place the lower 24 bits of the result in the `sequence` field of the `TxIn`, prefixed with `0x80`.

Complete `build_commitment_input` in `src/exercises_appendix/exercises.rs`. This function takes the following parameters:
- `funding_outpoint`: The OutPoint (`&OutPoint`) referencing the funding transaction 2-of-2 output.
- `commitment_transaction_number_obscure_factor`: The obscure factor (`&u64`) derived from payment basepoints.
- `commitment_number`: The commitment number (`&u64`) to obscure.

```rust
pub fn build_commitment_input(
    funding_outpoint: &OutPoint,
    commitment_transaction_number_obscure_factor: &u64,
    commitment_number: &u64,
) -> TxIn {
    // Step 1: Compute the Obscured Commitment Number

    // Step 2: Construct the Sequence Field

    // Step 3: Build and Return the TxIn
}
```
<details> <summary> Step 1: Compute the Obscured Commitment Number </summary>

Calculate the obscured commitment number by performing an XOR operation between the commitment number and the obscure factor.

```rust
let obscured_commitment_transaction_number = 
    commitment_transaction_number_obscure_factor ^ commitment_number;
```
- The `^` operator performs a bitwise XOR between the two `u64` values.

</details>

<details> <summary> Step 2: Construct the Sequence Field </summary>

Extract the lower 24 bits of the obscured commitment number and prefix them with `0x80` to form the `sequence` field value.

```rust
let sequence = Sequence(((0x80 as u32) << 8 * 3) | ((obscured_commitment_transaction_number >> 3 * 8) as u32));
```
- `(obscured_commitment_transaction_number >> 3 * 8)` shifts the obscured number right by 24 bits (3 bytes) to isolate the lower 24 bits.
- `(0x80 as u32) << 8 * 3` shifts `0x80` left by 24 bits to place it in the most significant byte of the 32-bit sequence field.
- The `|` operator combines the prefix (`0x80`) with the lower 24 bits to form the final sequence value.
- `Sequence(...)` wraps the `u32` value into a `Sequence` type, as required by the `TxIn` struct.

</details>

<details> <summary> Step 3: Build and Return the TxIn </summary>

Construct the `TxIn` struct with the funding outpoint, an empty script signature, the computed sequence, and an empty witness.

```rust
TxIn {
    previous_output: funding_outpoint,
    script_sig: ScriptBuf::new(),
    sequence,
    witness: Witness::new(),
}
```
- `previous_output`: `funding_outpoint` sets the input to spend the funding transaction’s output.
- `script_sig`: `ScriptBuf::new()` provides an empty script signature, as the commitment transaction uses a witness for the 2-of-2 multisig.
- `sequence` uses the value computed in Step 2, containing the lower 24 bits of the obscured commitment number.
- witness: `Witness::new()` provides an empty witness, to be populated later when signing the transaction.

</details>

## ⚡️ Write A Function To Build A Commitment Transaction Locktime
Let's close the loop by writing a function to construct a `LockTime` value for a given commitment transaction. Like the above, this function will XOR the commitment number with the obscure factor and place the lower 24 bits of the result in the `locktime` field, prefixed with `0x20.`

Complete `build_commitment_locktime` in `src/exercises_appendix/exercises.rs`. This function takes the following parameters:
- `commitment_transaction_number_obscure_factor`: The obscure factor (`&u64`) derived from payment basepoints.
- `commitment_number`: The commitment number (`&u64`) to obscure.

```rust
pub fn build_commitment_locktime(
    commitment_transaction_number_obscure_factor: &u64,
    commitment_number: &u64,
) -> LockTime {
    // Step 1: Compute the Obscured Commitment Number

    // Step 2: Construct and Return the LockTime
}
```
<details> <summary> Step 1: Compute the Obscured Commitment Number </summary>

The first step is the same as the last exercise - calculate the obscured commitment number by performing an XOR operation between the commitment number and the obscure factor.

```rust
let obscured_commitment_transaction_number = 
    commitment_transaction_number_obscure_factor ^ commitment_number;
```
- The `^` operator performs a bitwise XOR between the two `u64` values.

</details>

<details> <summary> Step 2: Construct and Return the LockTime </summary>

Extract the lower 24 bits of the obscured commitment number and prefix them with `0x20` to form the `locktime` field value.

```rust
LockTime::from_consensus(((0x20 as u32) << 8 * 3) | ((obscured_commitment_transaction_number & 0xffffffu64) as u32))
```
- `(obscured_commitment_transaction_number & 0xffffffu64)` masks the lower 24 bits (using `0xffffff` which is `000000000000000000000000000000000000000000000000111111111111111111111111` in binary). This extracts only the lower 24 bits from the 48-bit obscured commitment number, effectively truncating it.
- `(0x20 as u32) << 8 * 3` shifts `0x20` left by 24 bits to place it in the most significant byte of the 32-bit locktime field.
- The `|` operator combines the prefix (`0x20`) with the lower 24 bits to form the final locktime value.
- `LockTime::from_consensus(...)` creates a LockTime from the u32 value.

</details>